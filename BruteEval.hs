module BruteEval
( reduceStep, -- Given the symbol definitions apply to a Term a single reduction step (if there is a redex).
  reduceAll   -- Given the symbol definitions reduce a Term until no reduction step is applicable.
) where
import Common
import Utils

import Data.Maybe
import Data.List
import Control.Applicative
import qualified Data.Map as M

-- Given a term returns the defined symbol if it's an evaluation context.
evalSymbol :: Term -> Maybe Symbol
evalSymbol (Var x) = Just x
evalSymbol (App e _) = evalSymbol e
evalSymbol (Destructor _ e) = evalSymbol e
evalSymbol _ = Nothing

{- Given a pattern p and Term t, returns the Substitution generated by matching
   p =? t, returns Nothing if doesn't match. -}
matchPattern :: Pattern -> Term -> Maybe Substitution
matchPattern (PVar x) t = return [(x,t)]
matchPattern PUnit Unit = return []
matchPattern (PConstructor c' p) (Constructor c t) = if c==c' then matchPattern p t else Nothing
matchPattern (PTuple p1 p2) (Tuple t1 t2) = do sub1 <- matchPattern p1 t1
                                               sub2 <- matchPattern p2 t2
                                               return (sub1++sub2)
matchPattern _ _ = Nothing

{- Given a copattern q and Term t, returns the Substitution generated by matching
   q =? t, returns Nothing if doesn't match. -}
matchCopattern :: Copattern -> Term -> Maybe Substitution
matchCopattern (CHole f) (Var f') = if f==f' then return [] else Nothing
matchCopattern (CApp q p) (App t1 t2) = do sub <- matchCopattern q t1
                                           sub' <- matchPattern p t2
                                           return (sub++sub')
matchCopattern (CDestructor d' q) (Destructor d t) = if d==d' then matchCopattern q t else Nothing
matchCopattern _ _ = Nothing

{- If Term matches with l.h.s. Rule returns the respective contraction (r.h.s.
  applying the Substitution yield by matching). -}
contractByRule :: Term -> Rule -> Maybe Term
contractByRule t rule = do sub <- matchCopattern (getCopattern rule) t
                           return (termSubstitution sub (getTerm rule))

{- Given the symbol definitions and a Term t, returns t' if t is a redex and
   contract to t'. Returns Nothing if t is not a redex. -}
contractTerm :: SymbolDefs -> Term -> Maybe Term
contractTerm defs t = do fSymbol <- evalSymbol t
                         fRules <- map getDef <$> snd <$> M.lookup fSymbol defs
                         (foldl1' (<|>) . map (contractByRule t)) fRules

{- Given the symbol definitions and a Term t, returns a Term t' that can be
   obtained from t applying one step reduction (a contraction of a redex subterm)
   returns Nothing if there is no such t'. -}
reduceStep :: Program -> Term -> Maybe Term
reduceStep (_,defs) = red
  where red t = contractTerm defs t <|>
          case t of
            (Var _)  -> Nothing
            Unit    -> Nothing
            (Tuple t1 t2) -> liftA2 Tuple (red t1) (pure t2) <|> liftA2 Tuple (pure t1) (red t2)
            (Constructor c t) -> liftA (Constructor c) (red t)
            (App t1 t2)       -> liftA2 App (red t1) (pure t2) <|> liftA2 App (pure t1) (red t2)
            (Destructor d t)  -> liftA (Destructor d) (red t)

-- Given the symbol definitions reduce a Term until no reduction step is applicable.
reduceAll :: Program -> Term -> Term
reduceAll p t = maybe t (reduceAll p) (reduceStep p t)
